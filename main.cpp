/*
 * Copyright 2020-2022 NXP
 * All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include "board_init.h"
#include "demo_config.h"
#include "demo_info.h"
#include "fsl_debug_console.h"
#include "image.h"
#include "image_utils.h"
#include "model.h"
#include "output_postproc.h"
#include "timer.h"
//#include <cstdint> // int8_t
#include <cstring>  // 使用 memcpy
#include <cfloat>   // 使用 FLT_MAX, FLT_MIN

#define mmax(a,b)  ((a)>(b) ? (a):(b))
#define mmin(a,b)  ((a)<(b) ? (a):(b))
//#include "ecg_load.h"
float ECGbufferF[256] = {-102,-94,-86,-78,-71,-64,-54,-43,-35,-29,-22,-12,-2,8,15,21,27,29,31,34,40,47,52,58,59,63,61,60,58,55,60,58,53,49,45,40,36,36,35,31,27,22,13,7,0,1,-1,-2,-10,-15,-23,-33,-36,-43,-43,-50,-53,-56,-61,-64,-66,-68,-70,-72,-71,-76,-81,-82,-84,-81,-73,-65,-59,-54,-51,-47,-42,-38,-35,-32,-29,-26,-23,-20,-18,-19,-24,-33,-47,-61,-76,-86,-93,-98,-99,-95,-98,-98,-98,-98,-98,-99,-100,-100,-101,-99,-100,-97,-93,-89,-90,-95,-102,-110,-119,-120,-123,-113,-93,-54,-2,69,145,218,295,362,418,458,478,468,439,395,337,270,195,118,31,-49,-115,-154,-168,-159,-148,-140,-137,-143,-149,-159,-164,-171,-177,-183,-186,-185,-186,-186,-186,-187,-191,-193,-201,-200,-202,-204,-204,-202,-204,-205,-205,-208,-209,-209,-208,-208,-209,-210,-207,-208,-204,-197,-191,-187,-183,-183,-181,-177,-173,-167,-158,-148,-141,-131,-128,-122,-119,-112,-104,-96,-86,-74,-65,-55,-44,-34,-24,-19,-10,-7,-6,-5,-1,4,10,17,25,31,35,37,37,38,41,36,34,31,27,28,28,29,29,28,20,14,5,0,-9,-10,-8,-11,-15,-21,-25,-34,-40,-47,-53,-58,-66,-73,-76,-80,-81,-81,-82,-81,-83,-86
};
float ECGbufferN[256] = {-57,-56,-60,-60,-61,-59,-60,-62,-62,-61,-59,-57,-57,-58,-59,-62,-58,-59,-60,-61,-62,-65,-62,-60,-58,-62,-65,-66,-63,-60,-61,-62,-64,-66,-65,-63,-62,-61,-61,-62,-60,-61,-58,-60,-60,-61,-61,-58,-56,-59,-61,-63,-61,-59,-58,-56,-54,-55,-55,-54,-50,-50,-51,-45,-44,-41,-40,-41,-43,-46,-44,-45,-45,-45,-46,-47,-48,-47,-44,-42,-41,-49,-57,-57,-60,-62,-66,-66,-65,-63,-64,-63,-65,-68,-69,-68,-68,-70,-69,-71,-66,-67,-66,-64,-69,-71,-68,-66,-65,-66,-70,-73,-72,-76,-85,-89,-95,-102,-107,-101,-83,-60,-32,-3,47,98,144,175,188,181,151,98,33,-22,-54,-78,-90,-95,-91,-85,-78,-78,-77,-78,-76,-76,-76,-79,-77,-77,-77,-75,-79,-82,-82,-80,-79,-78,-81,-79,-77,-75,-78,-78,-81,-82,-82,-78,-78,-79,-81,-83,-80,-82,-81,-82,-83,-82,-80,-80,-79,-78,-81,-82,-78,-78,-77,-77,-82,-81,-79,-78,-75,-78,-79,-82,-80,-78,-78,-77,-81,-83,-83,-80,-79,-81,-83,-84,-84,-82,-83,-85,-84,-87,-86,-86,-84,-86,-90,-91,-90,-87,-89,-90,-91,-94,-92,-91,-90,-91,-94,-95,-92,-90,-89,-88,-87,-88,-82,-79,-74,-73,-72,-73,-68,-65,-63,-64,-66,-66,-64,-62,-60,-60,-64,-64
};
float ECGbufferQ[256] = {-38,-35,-38,-41,-42,-40,-39,-42,-46,-47,-49,-47,-46,-46,-49,-54,-52,-48,-45,-44,-45,-45,-45,-45,-44,-47,-52,-52,-52,-52,-51,-51,-52,-52,-53,-50,-48,-51,-53,-56,-52,-51,-50,-49,-50,-51,-49,-48,-50,-49,-53,-54,-50,-50,-49,-50,-51,-51,-48,-49,-53,-52,-54,-56,-56,-53,-53,-52,-53,-51,-49,-46,-46,-47,-46,-47,-43,-38,-35,-35,-39,-45,-45,-45,-46,-43,-45,-45,-41,-33,-27,-27,-29,-33,-34,-34,-37,-41,-45,-46,-39,-31,-24,-14,-1,43,115,169,160,105,55,36,39,46,51,56,57,60,64,68,71,69,66,64,68,76,80,82,79,73,67,62,52,39,25,10,-7,-26,-50,-71,-84,-87,-79,-76,-78,-81,-88,-93,-94,-92,-87,-84,-81,-76,-68,-62,-59,-61,-62,-64,-64,-62,-62,-61,-58,-58,-53,-52,-48,-49,-48,-47,-43,-40,-39,-41,-43,-40,-40,-38,-38,-38,-37,-39,-37,-35,-33,-34,-34,-32,-30,-28,-27,-27,-30,-30,-28,-26,-24,-24,-23,-23,-20,-18,-17,-16,-18,-18,-16,-12,-12,-10,-9,-14,-11,-11,-8,-8,-9,-10,-10,-10,-10,-10,-10,-13,-13,-13,-14,-14,-18,-21,-21,-21,-22,-22,-28,-30,-30,-31,-30,-31,-37,-37,-36,-37,-35,-38,-41,-45,-44,-41,-40,-43,-45,-45
};
float ECGbufferS[256] = {-33,-35,-39,-43,-46,-48,-49,-46,-40,-37,-36,-37,-37,-39,-38,-38,-40,-39,-40,-43,-43,-44,-44,-41,-38,-37,-36,-36,-39,-45,-49,-51,-52,-50,-50,-47,-44,-44,-45,-48,-46,-49,-51,-53,-52,-50,-50,-49,-48,-45,-43,-41,-38,-38,-36,-34,-33,-34,-32,-33,-35,-37,-38,-38,-40,-38,-41,-44,-46,-45,-42,-43,-39,-36,-35,-33,-35,-35,-34,-35,-36,-38,-39,-35,-31,-29,-31,-30,-32,-30,-29,-30,-32,-34,-38,-36,-37,-36,-35,-39,-38,-38,-38,-36,-34,-34,-32,-29,-28,-27,-27,-29,-29,-31,-34,-33,-33,-30,-26,-21,-17,-11,-2,9,29,44,65,88,104,112,103,75,27,-24,-66,-91,-103,-105,-101,-93,-86,-80,-77,-77,-78,-80,-77,-69,-65,-58,-57,-57,-60,-64,-66,-66,-62,-61,-57,-56,-51,-45,-41,-36,-34,-29,-28,-28,-29,-32,-32,-34,-35,-35,-34,-33,-31,-29,-29,-28,-28,-26,-30,-31,-31,-31,-32,-32,-29,-30,-30,-28,-26,-26,-25,-27,-24,-26,-25,-26,-23,-22,-20,-20,-19,-19,-20,-24,-24,-22,-18,-13,-13,-7,-5,0,-1,-2,-2,-2,1,5,7,10,11,13,16,20,21,19,20,20,19,22,21,21,20,19,17,16,13,11,12,8,5,1,-2,-4,-4,-5,-5,-4,-8,-10,-15,-20
};
float ECGbufferV[256] = {-84,-85,-87,-87,-89,-86,-85,-85,-87,-85,-82,-81,-84,-84,-88,-89,-85,-82,-83,-86,-89,-92,-88,-86,-87,-89,-90,-91,-94,-92,-94,-95,-98,-98,-97,-94,-96,-99,-99,-95,-95,-95,-92,-93,-90,-87,-84,-79,-79,-79,-78,-80,-73,-69,-67,-66,-66,-66,-62,-60,-61,-59,-60,-61,-59,-57,-58,-59,-64,-62,-61,-58,-62,-62,-63,-63,-59,-59,-60,-61,-62,-64,-61,-61,-60,-62,-64,-65,-63,-63,-63,-65,-68,-70,-66,-66,-66,-68,-67,-69,-69,-67,-66,-67,-72,-74,-73,-71,-76,-77,-83,-88,-90,-95,-101,-102,-110,-125,-159,-211,-270,-337,-398,-443,-478,-505,-524,-539,-543,-538,-525,-507,-484,-452,-410,-361,-316,-271,-230,-187,-149,-116,-87,-66,-54,-49,-46,-41,-31,-22,-13,-12,-9,-7,-1,4,8,10,13,17,24,28,29,29,26,26,29,33,35,38,40,43,46,50,53,58,58,55,52,53,51,51,49,48,52,54,56,57,55,59,65,69,72,74,76,79,83,90,96,97,101,109,117,122,129,132,136,142,148,156,162,166,166,174,177,186,188,187,187,187,190,192,191,191,189,189,192,189,187,181,172,164,157,151,141,131,117,107,95,84,74,60,50,38,29,20,11,4,-4,-9,-14,-16,-23,-28,-35,-37
};

float* ECGbuffers[] = {ECGbufferF, ECGbufferN, ECGbufferQ, ECGbufferS, ECGbufferV};
const char* ECGbufferNames[] = {"F", "N", "Q", "S", "V"}; // 標記 ECG 類別

// **修正後的標準化函式**
void normalize(float *data, int length) {
    float amin = data[0];
    float amax = data[0];

    // 計算最大值與最小值
    for (int i = 1; i < length; ++i) {
        amin = mmin(data[i], amin);
        amax = mmax(data[i], amax);
    }

    // 防止除以零
    const float EPSILON = 1e-6f;
    if ((amax - amin) < EPSILON) {
        PRINTF("Warning: Data has no variation, normalization skipped.\n");
        return;
    }

    // 進行歸一化
    for (int i = 0; i < length; ++i) {
        data[i] = (data[i] - amin) / (amax - amin);
    }
}

int main(void)
{
    BOARD_Init();
    TIMER_Init();

    // 標準化所有 ECG buffer
    const int numBuffers = sizeof(ECGbuffers) / sizeof(ECGbuffers[0]);
    const int bufferSize = 256;
    for (int i = 0; i < numBuffers; i++) {
        PRINTF("Normalizing ECGbuffer%s..." EOL , ECGbufferNames[i]);
        normalize(ECGbuffers[i], bufferSize);
    }
    PRINTF("All ECG buffers have been normalized." EOL);

    DEMO_PrintInfo();

    if (MODEL_Init() != kStatus_Success)
    {
        PRINTF("Failed initializing model" EOL);
        for (;;) {}
    }

    tensor_dims_t inputDims = {1, 256, 1};  // 輸入張量的尺寸為 {3, {1, 256, 1}}; size = 3，表示這個張量有 3 個維度
    tensor_type_t inputType;   // 輸入類型為 INT8 = kTensorType_FLOAT32;
//    uint8_t* inputData = MODEL_GetInputTensorData(&inputDims, &inputType);
    void* inputData = MODEL_GetInputTensorData(&inputDims, &inputType);
//    if (inputType == kTensorType_FLOAT32) {
//        float* floatInputData = (float*)inputData;
//    } else if (inputType == kTensorType_INT8) {
//        int8_t* int8InputData = (int8_t*)inputData;
//    } else {
//        uint8_t* uint8InputData = (uint8_t*)inputData;
//    }
//    PRINTF("Input tensor dimensions size: %d\n" EOL, inputDims.size);
//    PRINTF("Input tensor shape: [%d, %d, %d, %d]\n" EOL, inputDims.data[0], inputDims.data[1], inputDims.data[2],inputDims.data[3]);//inputDims.data[3]

    tensor_dims_t outputDims = {1, 5};  // 輸出張量的尺寸為 [1, 5]
    tensor_type_t outputType = kTensorType_FLOAT32;  // 輸出類型為 FLOAT32
//    uint8_t* outputData = MODEL_GetOutputTensorData(&outputDims, &outputType);
    void* outputData = MODEL_GetOutputTensorData(&outputDims, &outputType);


        /* Expected tensor dimensions: [batches, height, width, channels] */
//        if (IMAGE_GetImage(inputData, inputDims.data[2], inputDims.data[1], inputDims.data[3]) != kStatus_Success)
//        {
//            PRINTF("Failed retrieving input image" EOL);
//            for (;;) {}
//        }
        // 讀取 ECG 資料
//        ECG_GetData(inputData, 256);

    for (int i = 0; i < numBuffers; i++) {
        PRINTF("Running inference on ECGbuffer%s..." EOL, ECGbufferNames[i]);
//        int8_t* int8Data = reinterpret_cast<int8_t*>(inputData);
//        memcpy(int8Data, ECGbuffers[i], sizeof(ECGbuffers[i]));

        float* f32Data = reinterpret_cast<float*>(inputData);
        memcpy(f32Data, ECGbuffers[i], bufferSize * sizeof(float));


        MODEL_ConvertInput(inputData, &inputDims, inputType);

        auto startTime = TIMER_GetTimeInUS();
        MODEL_RunInference();
        auto endTime = TIMER_GetTimeInUS();

        MODEL_ProcessOutput(outputData, &outputDims, outputType, endTime - startTime);
    }

}

